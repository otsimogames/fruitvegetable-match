// Code generated by protoc-gen-js-fetch.
// DO NOT EDIT!
import fetch, { Headers, RequestInit, Request } from 'node-fetch';
import * as otsimo_i18n_i18n from "./i18n.pb";

export class LanguageListing {
  languageCode: string;
  limit: number;
  skip: number;
  notTranslated: boolean;
  searchText: string;
}

export class TagQuery {
  languageCode: string;
  tags: string[];
}

export class TaskAddTag {
  textName: string;
  tag: string;
}

export class TaskRemoveTag {
  textName: string;
  tag: string;
}

export class TaskAddText {
  languageCode: string;
  textName: string;
  text: string;
}

export class TaskUpdateText {
  languageCode: string;
  textName: string;
  text: string;
}

export class TaskRemoveTextTagComment {
  textName: string;
}

export class TaskAddLanguage {
  language: otsimo_i18n_i18n.Language;
}

export class TaskRemoveLanguage {
  languageCode: string;
}

export class TaskUpdateLanguage {
  language: otsimo_i18n_i18n.Language;
}

export class TaskAddComment {
  textName: string;
  comment: string;
}

export class TaskUpdateComment {
  textName: string;
  comment: string;
}

export class TaskRemoveComment {
  textName: string;
  comment: string;
}

export class Task {
  addText: TaskAddText;
  updateText: TaskUpdateText;
  removeText: TaskRemoveTextTagComment;
  addTag: TaskAddTag;
  removeTag: TaskRemoveTag;
  addLang: TaskAddLanguage;
  removeLang: TaskRemoveLanguage;
  updateLang: TaskUpdateLanguage;
  addComment: TaskAddComment;
  updateComment: TaskUpdateComment;
  removeComment: TaskRemoveComment;
}

export class BatchTask {
  transaction: boolean;
  tasks: Task[];
}

export class TaskResult {
  errors: string[];
}

export class BatchTextReq {
  languageCode: string;
  texts: string[];
  includeComments: boolean;
  includeTags: boolean;
}

export class BatchTextLangReq {
  text: string;
  languageCodes: string[];
}

export class LocalizationService {
    private host:string;
    private headerEditors :any[]= [];
 /**
  * @param {string} url the service host url
  */
  constructor(url: string) {
    this.host = url;
    this.headerEditors=[];
  }

  addHeaderEditor(m: any) {
    this.headerEditors.push(m)
  }

  async getLanguages(): Promise<otsimo_i18n_i18n.Languages> {
	const _headers = new Headers();
	_headers.append("Content-Type", "application/json");
	for (let i = 0; i < this.headerEditors.length; ++i) {
	  this.headerEditors[i].edit(_headers);
	}
	const _init = {
	  method: 'GET',
	  headers: _headers,
	  body: undefined,
	} as RequestInit;
	
	const _req = new Request(`${this.host}/api/v1/i18n/languages`, _init);
	try {
	  const resp = await fetch(_req);
	  return resp.json();
	} catch (err) {
	  return Promise.reject(err);
	}
  }

   
  async queryWithTag(tagQuery: TagQuery): Promise<otsimo_i18n_i18n.LanguageEntries> {
	const _headers = new Headers();
	_headers.append("Content-Type", "application/json");
	for (let i = 0; i < this.headerEditors.length; ++i) {
	  this.headerEditors[i].edit(_headers);
	}
	const _init = {
	  method: 'POST',
	  headers: _headers,
	  body: JSON.stringify(tagQuery),
	} as RequestInit;
	
	const _req = new Request(`${this.host}/api/v1/i18n/tags`, _init);
	try {
	  const resp = await fetch(_req);
	  return resp.json();
	} catch (err) {
	  return Promise.reject(err);
	}
  }

   
  async listTextsForLanguage(languageListing: LanguageListing): Promise<otsimo_i18n_i18n.LanguageEntries> {
	const _headers = new Headers();
	_headers.append("Content-Type", "application/json");
	for (let i = 0; i < this.headerEditors.length; ++i) {
	  this.headerEditors[i].edit(_headers);
	}
	const _init = {
	  method: 'POST',
	  headers: _headers,
	  body: JSON.stringify(languageListing),
	} as RequestInit;
	
	const _req = new Request(`${this.host}/api/v1/i18n/language/list`, _init);
	try {
	  const resp = await fetch(_req);
	  return resp.json();
	} catch (err) {
	  return Promise.reject(err);
	}
  }

   
  async executeTasks(batchTask: BatchTask): Promise<TaskResult> {
	const _headers = new Headers();
	_headers.append("Content-Type", "application/json");
	for (let i = 0; i < this.headerEditors.length; ++i) {
	  this.headerEditors[i].edit(_headers);
	}
	const _init = {
	  method: 'POST',
	  headers: _headers,
	  body: JSON.stringify(batchTask),
	} as RequestInit;
	
	const _req = new Request(`${this.host}/api/v1/i18n/execute`, _init);
	try {
	  const resp = await fetch(_req);
	  return resp.json();
	} catch (err) {
	  return Promise.reject(err);
	}
  }

   
  async getTexts(batchTextReq: BatchTextReq): Promise<otsimo_i18n_i18n.LanguageEntries> {
	const _headers = new Headers();
	_headers.append("Content-Type", "application/json");
	for (let i = 0; i < this.headerEditors.length; ++i) {
	  this.headerEditors[i].edit(_headers);
	}
	const _init = {
	  method: 'POST',
	  headers: _headers,
	  body: JSON.stringify(batchTextReq),
	} as RequestInit;
	
	const _req = new Request(`${this.host}/api/v1/i18n/batch`, _init);
	try {
	  const resp = await fetch(_req);
	  return resp.json();
	} catch (err) {
	  return Promise.reject(err);
	}
  }

   
  async getAllTextsForLanguages(batchTextLangReq: BatchTextLangReq): Promise<otsimo_i18n_i18n.LanguageEntries> {
	const _headers = new Headers();
	_headers.append("Content-Type", "application/json");
	for (let i = 0; i < this.headerEditors.length; ++i) {
	  this.headerEditors[i].edit(_headers);
	}
	const _init = {
	  method: 'POST',
	  headers: _headers,
	  body: JSON.stringify(batchTextLangReq),
	} as RequestInit;
	
	const _req = new Request(`${this.host}/api/v1/i18n/text`, _init);
	try {
	  const resp = await fetch(_req);
	  return resp.json();
	} catch (err) {
	  return Promise.reject(err);
	}
  }

   }
